// $Author: beo1 $
// $Id: Logo.jj 1354 2012-12-05 14:28:28Z beo1 $
//
// Parser and translateor of a subset of Logo into Java

options {
   FORCE_LA_CHECK = true;
//   DEBUG_PARSER = true;
//   DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(Logo)
package ch.m02.comet.afl.model;

import java.lang.*;
import java.io.*;
import java.util.*;

public class Logo {

  static private File javaFile, htmlFile;   // output files
  static private PrintWriter pw;            // printwriter used for every output
  static private int numIndent = 0;         // size of indentation
  static private int forCounter = 0;		// for loop with i, j, k, ...
  
  // to pretty-print the translation
  // uses numIndent and pw defined as static variables in LogoParser
  // writes in pw the numIndent times the indent string
  public static void indent() {
    for (int i=0; i<numIndent; i++) { pw.print("   "); }
  }

  /**
   * Main method that reads the source file(s) ".logo" and translates it into 
   * two files: ".java" ".html".
   * <p>
   * First parameter (<code>args[0]</code>): The file for logo sources.
   * If it is a directory all files in the directory will be translated.
   * <p>
   * Second (optional) parameter (<code>args[1]</code>): Output directory for
   * the generated files. If ommited the current execution directory will be
   * used.
   */
  public static void main(String args[]) throws Exception {
    if (args.length < 1) {
      throw new IllegalArgumentException("Need fileName/sourceDirectory as primary argument");
    }
    String inputFile = args[0];
    System.out.println("Got input file: " + inputFile);
	
    String outputPath = "";
    if (args.length >= 2) {
      outputPath = args[1];
      System.out.println("Got output path: " + outputPath);
    }
	
    File input = new File(inputFile);
    List<File> logoFiles = new ArrayList<File>();
    if (input.isDirectory()) {
      File[] inputFiles = input.listFiles(new FilenameFilter() {
        public boolean accept(File dir, String filename) {
          return filename.endsWith(".logo");
        }
      });
      logoFiles.addAll(Arrays.asList(inputFiles));
    } else {
      logoFiles.add(input);
    }
    
    for (File f : logoFiles) {
      parseFile(f, outputPath);
    }
  }
  
  public static void parseFile(File logoFile, String outputPath) throws Exception {
	BufferedReader in = null;
	try {
      in = new BufferedReader(new FileReader(logoFile));
      Logo parser = new Logo(in);
      System.out.println("Processing " + logoFile.getName());
      parser.start(outputPath);
      System.out.println("Processing DONE");
    } catch (ParseException x) {
      System.out.println("Syntaxtic Error");
      throw x;
    } catch (TokenMgrError x) {
      System.out.println("Lexical Error");
      throw x;
    } finally {
	  if (in != null) {
        try {
          in.close();
        } catch (Exception e) {
          e.printStackTrace();
        }
      }
    }
  }
}
PARSER_END(Logo)

// skip separators
SKIP : { <" " | "\t" | "\n" | "\r"> }

// Constants, pre-defined, operators etc.
TOKEN: { <ADD: "+">   | <SUB: "-">  | <MUL: "*"> | <DIV: "/"> }
TOKEN: { <LPAR: "(">  | <RPAR: ")"> | <#PARSEP: ":"> }
TOKEN: { <LBRA: "[">  | <RBRA: "]"> }
TOKEN: { <EQ: "==">   | <NE: "!=">  }
TOKEN: { <LT: "<">    | <GT: ">">   | <LE: "<="> | <GE: ">="> }
TOKEN: { <AND: "AND"> | <OR: "OR"> }
TOKEN: { <TRUE: "TRUE"> | <FALSE: "FALSE"> | <NOT: "NOT"> }
// REPCOUNT is a pre-defined identifier rather than a keyword
TOKEN: { <REPCOUNT: "REPCOUNT"> }
// Keywords
TOKEN: {
  <CLEARSCREEN: "CS"> |
  <PENDOWN: "PD">     | <PENUP: "PU">      |
  <FORWARD: "FD">     | <BACKWARD: "BK">   |
  <LEFTTURN: "LT">    | <RIGHTTURN: "RT">  |
  <HIDETURTLE: "HT">  | <SHOWTURTLE: "ST"> |
  <WAIT: "WAIT">      | <REPEAT: "REPEAT"> |
  <IF: "IF">          | <IFELSE: "IFELSE"> |
  <SUBROUTINE: "TO">  |
  <LOGO: "LOGO">      | <END: "END">
}
// Numerical values, identifiers, and parameters
TOKEN: { <#DIGIT:  ["0"-"9"]> }
TOKEN: { <#LETTER: ["A"-"Z"]> }
TOKEN: { <NUM: (<DIGIT>)+ | (<DIGIT>)+ "." (<DIGIT>)+ > }
TOKEN: { <IDENTIFIER: <LETTER> ( <LETTER> | <DIGIT> )* > }
TOKEN: { <PARAMETER: <PARSEP> <IDENTIFIER> > // removes parameter separator
//          { matchedToken.image=image.substring(1,image.length()); }
}

SPECIAL_TOKEN : {
    <SINGLE_LINE_COMMENT: "#"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? > } 

void start(String outputPath) throws IOException: { Token t; } {
  // logo programs start with LOGO followed by an identifier
  <LOGO> 
  t = <IDENTIFIER> {
    
    // Determine class name
    String className = t.image.substring(0, 1).toUpperCase() + t.image.substring(1).toLowerCase();
    String packagePath = "ch" + File.separator + "m02" + File.separator + "comet" + File.separator + "afl" + File.separator + "parser";
    // Creation of the output files
    
//    // Create the HTML file for the applet
//    htmlFile = new File(t.image.toLowerCase() + ".html");
//    pw = new PrintWriter(new FileOutputStream(htmlFile));
//    pw.println("<html>");
//    pw.println("  <body>");
//    pw.println("  <applet code='" + t.image.toLowerCase() +
//               ".class'width=600 height=600></applet>");
//    pw.println("  </html>");
//    pw.println("</body>");
//    pw.close()
	 
    //Create the Java file and the class
    javaFile = new File(outputPath + File.separator + packagePath + File.separator + className + ".java");
    if (!javaFile.exists()) {
      javaFile.getParentFile().mkdirs();
      javaFile.createNewFile();
    }
    pw = new PrintWriter(new FileOutputStream(javaFile));
    pw.println("package ch.m02.comet.afl.parser;");
    pw.println();
    pw.println("import java.awt.Graphics;");
    pw.println("import ch.m02.comet.afl.parser.logo.LogoPrimitives;");
    pw.println();
    
    pw.println("public class " + className +
                    " extends java.applet.Applet {\n" );
    numIndent++;
    indent();
    pw.println("private LogoPrimitives logo;\n");
    pw.flush();
    indent();
    
    // Open the necessary method "paint" of the applet
    pw.println("public void paint(Graphics g) {");
    numIndent++;
    indent();
    pw.println("logo = new LogoPrimitives(this);");
    
	pw.println();
  }
  (subroutine())*
  (statement())*
  {
	pw.println();
    
    // close the method "paint"
    numIndent--;
    indent();
    pw.println("}");
    pw.println();
    
    // close the class
    numIndent--;
    indent();
    pw.println("}");
    pw.flush();
    pw.close(); 
  }
  <END>
}

void subroutine():
{
	Token t;
}
{
	<SUBROUTINE> 
	t = <IDENTIFIER>
	(getParameter())*
	(statement())*
	<END>
}



void statement():
{	
	String b;
	String i;
}
{
	<CLEARSCREEN>
	{ pw.println("logo.cs();"); pw.flush(); }
	
	|<PENDOWN>
	{ pw.println("logo.pd();"); pw.flush(); }
	
	|<PENUP>
	{ pw.println("logo.pu();"); pw.flush(); }
	
	|<FORWARD>
	i = nexpr()
	{ pw.println("logo.fd(" + i + ");"); pw.flush(); }
	
	|<BACKWARD>
	i = nexpr()
	{ pw.println("logo.bk(" + i + ");"); pw.flush(); }
	
	|<LEFTTURN>
	i = nexpr()
	{ pw.println("logo.lt(" + i + ");"); pw.flush();}
	
	|<RIGHTTURN>
	i = nexpr()
	{ pw.println("logo.rt(" + i + ");"); pw.flush();}
	
	|<HIDETURTLE>
	{ pw.println("logo.ht();"); pw.flush(); }
	
	|<SHOWTURTLE>
	{ pw.println("logo.st();"); pw.flush(); }
	
	|<WAIT>
	i = nexpr()
	{ pw.println("logo.wait(" + i + ");"); pw.flush(); }
	
	|<REPEAT>
	{forCounter++;}
	i = nexpr()
	{ char c = (char)(forCounter + 104) ; pw.println("for(int " + c + " = 1 ; " + c + " <= " + i + "; " + c + "++){"); pw.flush(); }
	<LBRA>(statement())*<RBRA>
	{ pw.println("}"); pw.flush(); }
	{forCounter--;}
	
	|<IF>
	b = bexpr()
	{ pw.println("if(" + b + "){"); pw.flush(); }
	<LBRA>(statement())*<RBRA>
	{ pw.println("}"); pw.flush(); }
	
	|<IFELSE>
	b = bexpr()
	<LBRA>(statement())*<RBRA><LBRA>(statement())*<RBRA>
	{ pw.println("if(" + b + "){  ??????????????????  }else{  ????????????????????  }"); pw.flush(); }
	
	|<SUBROUTINE>
}

String nexpr():
{
	String i;
	String res = "";
}
{
	res = nterm()
	( <ADD> 
		i = nterm()
		{ res = res + " + " + i; }
		| <SUB> 
		i = nterm()
		{ res = res + " - " + i; }
	)*
	{ return res; }
}

String nterm():
{
	String i;
	String res = "";
}
{
	res = nfactor()
	( <MUL> 
		i = nfactor()
		{ res = res + " * " + i; }
		| <DIV> 
		i = nfactor()
		{ res = res + " / " + i; }
	)*
	{ return res; }
}

String nfactor():
{
	int i;
	String res = "";
}
{
	(<SUB> (i = getNumber()
			{ res = res + "" + i;}  
			| <REPCOUNT>
			{ res = res + "" + (char)(forCounter + 104); }
			| <PARAMETER> 
			| (<LPAR> nexpr() <RPAR> )))
	|(		(i = getNumber()
			{ res = res + "" + i;} 
			| <REPCOUNT>
			{ res = res + "" + (char)(forCounter + 104); }
			| <PARAMETER> 
			| (<LPAR> nexpr() <RPAR> )))
	{ return res; }
}

String bexpr():
{
	String b;
	String res = "";
}
{
	res = bterm() 
	( <OR> 
		b = bterm() 
		{ res = res + " || " + b; }
	)*
	{ return res; }
}

String bterm():
{
	String b;
	String res = "";
}
{
	res = bfactor()
	( <AND> 
		b = bfactor()
		{ res = res + " && " + b; }
	)*
	{ return res; }
}

String bfactor():
{
	boolean b;
	String res = "";
}
{
	<TRUE>
	{ res = "TRUE"; } 
	| <FALSE> 
	{ res = "FALSE"; }
	| (<NOT> <LPAR> bexpr() <RPAR>) 
	| nexpr() ( <EQ> 
				| <NE> 
				| <LT> 
				| <GT> 
				| <LE> 
				| <GE> 
	) nexpr()
	{ return res; }
}

int getNumber() throws NumberFormatException:
{
	Token t;
}
{
	t = <NUM>
	{ return Integer.parseInt(t.image); }
}

String getParameter():
{
	Token t;
}
{
	t = <PARAMETER>
	{ return "" + t.image; }
}
